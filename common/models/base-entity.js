var async = require ('async');

module.exports = function(BaseEntity) {

    /*
        FailSafeObserver is a object wrapper on the observer function. Each obserever must have a unique id.
        
        TODO: Unique id can be automatically generated by creating a SHA1 hash of the observer function. However for 
        simplicity purpose, i have used an hardcoded id for each observer function. Developer has to generate the uid 
        and use it in the code for time being.
    */
    var FailSafeObserver = function (id, fn){
        var _id = id;
        var _fn = fn;
        
        /*
            Function to execute actual observer function. This is a wrapper which waits for the actual observer
            function to execute and after successful execution adds the id of the observer in the event history.
        */
        this.execute = function (timestamp, ctx, next) {
            _fn(ctx, function (){
                
                // make a note that the observer was executed for current event.
                ctx.Model._eventHistory[timestamp][id] = true;
                next ();
            });
        };
        
        /*
            Function returns the id of the observer.
        */
        this.getId = function () {
            return _id;
        };
    }
    
    /* _fsObservers variable holds list of observers registred against this model.
    For easy lookups following structure is used - 
    {
        "after save": {
            "observerIds :[],
            "observers" : [observer object]
        } 
    }
    
    */
    BaseEntity._fsObservers = {};

    /* Global variable to hold event history. History will also contain the information about observers it has executed successfully.
    Structure: {
        "event_occurance_timestamp": {
            "observer_id": true,
            "observer_id": true
        }
    }
    
    if any observer_id is not present for the given event_occurance_timestamp then it means that the event was not processed by that observer.
    */
    BaseEntity._eventHistory = {};
    

    /*
        EventReplayJob object. This is also a wrapper object which maintains a model reference and works on it. 
        The replayEvents methods goes throug the event history and compares data in it against the observers registered on the Model.
        
        If any of the observer is not found to be executed in the event history, it is suppose to replay the same same. This is still to be done.
    */
    
    var EventReplayJob = function (Model) {
        var _model = Model;
        
        this.replayEvents = function () {
            console.log ('Executing replay job...........................');

            // Get the events from event history;
            var pastEvents = _model._eventHistory;

            if (!pastEvents) {
                return;
            }

            var pastEventTimestamps = Object.keys (pastEvents);
            pastEventTimestamps.forEach (function (pastEventTimestamp){
                console.log ('Event @', pastEventTimestamp);

                var observerStatus = _model._eventHistory [pastEventTimestamp];

                // Get all the observer ids for this model.
                var registeredObserverIds = _model._fsObservers['after save'].observerIds;

                // Check if each observer was executed for event @ this timestamp
                for (var i =0; i < registeredObserverIds.length; i++) {
                    if (observerStatus [registeredObserverIds[i]]){
                        // observer was executed.
                        console.log ('Event @', pastEventTimestamp, ' Observer -', registeredObserverIds [i], ' -Successful');
                    }else {
                        // observer was not executed. we need to retrigger the event.
                        console.log ('Event @', pastEventTimestamp, ' Observer -', registeredObserverIds [i], ' -Failed');
                    }
                }
            });
        };
            
        this.start = function () {
            setInterval (this.replayEvents, 5000);
        }
     }
    
    /*
    Function to register a fail safe observer. This function expects an object of type FailSafeObserver and adds it to the list of observers.
    */
    
    BaseEntity.failSafeObserve = function (eventName, observer) {
        if (! observer instanceof FailSafeObserver ) {
            throw new Error ('observer should be an instanceof FailSafeObserver');
        }
        
        if (!this._fsObservers[eventName]) {
            this._fsObservers[eventName] = {"observers":[], "observerIds":[]};
        }
        
        this._fsObservers[eventName].observers.push (observer);
        this._fsObservers[eventName].observerIds.push (observer.getId());
        
        if (!this._replayJobStarted) {
            var job = new EventReplayJob (this);
            job.start();
            this._replayJobStarted = true;
        }
    }
    
    
    /*
        A temporary mechanism to invoke fail safe observers. Ideally we should override the notifyObserversOf () loopback method and 
        invoke fail safe observers there.
    */
    
    
    BaseEntity.observe ('after save', function (ctx, next){
        
        // Invoke failsafe observers in loop
        var fsObservers = ctx.Model._fsObservers['after save'].observers || [];
        var thisTimestamp = Date.now();
        
        ctx.Model._eventHistory[thisTimestamp] = {};
        
        async.eachSeries(fsObservers, function notifySingleObserver(fn, callback) {
            var retval = fn.execute(thisTimestamp, ctx, callback);
            
            if (retval && typeof retval.then === 'function') {
            retval.then(function() { 
                callback(); 
            }, callback);
        }
      },
      function(err) { next(); }
    );
    });
    
    BaseEntity.failSafeObserve ('after save', new FailSafeObserver ('45d8b8f0-ba34-4707-a303-852c96fdd1b2', function(ctx,next){
        console.log ('This is fail safe observer function...');
        
        next ();
    }));
 
};
